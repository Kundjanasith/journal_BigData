MapReduce & Hive
08:30 - 12:00
- MapReduce
--> is a programming model and an associated implementation for processing and generating large data sets with a parallel, distributed algorithm on a cluster
--> is similar approaches have been very well known since 1995 with the Message Passing Interface standard having reduce and scatter operations
--> is composed
- a Map() procedure (method) that performs filtering and sorting
- such as sorting students by first name into queues, one queue for each name
- a Reduce() method that performs a summary operation
- such as counting the number of students in each queue, yielding name frequencies
--> The MapReduce System
- Infrastructure or Framework orchestrates the processing by marshalling the distributed servers, running the various tasks in parallel, managing all communications and data transfers between the various parts of the system, and providing for redundancy and fault tolerance
--> The model is inspired by the map and reduce functions commonly used in functional programming although their purpose in the MapReduce framework is not the same as in their original forms
- The key contributions of the MapReduce framework are not the actual map and reduce functions, but the scalability and fault-tolerance achieved for a variety of applications by optimizing the execution engine once
- a single-threaded implementation of MapReduce will usually not be faster than a traditional (non-MapReduce) implementation; any gains are usually only seen with multi-threaded implementations
--> The use of this model is beneficial only when the optimized distributed shuffle operation
- Shuffle operation (which reduces network communication cost) and fault tolerance features of the MapReduce framework come into play
--> Optimizing the communication cost is essential to a good MapReduce algorithm
- MapReduce libraries have been written in many programming languages, with different levels of optimization
- A popular open-source implementation that has support for distributed shuffles is part of Apache Hadoop
--> is a framework for processing parallelizable problems across large datasets using a large number of computers (nodes)
- a cluster : if all nodes are on the same local network and use similar hardware
- a grid : if the nodes are shared across geographically and administratively distributed systems, and use more heterogenous hardware
--> Processing can occur on data stored
- a filesystem : unstructured
- a database : structured
- MapReduce can take advantage of the locality of data, processing it near the place it is stored in order to reduce the distance over which it must be transmitted
- Map step
- Each worker node applies the "map()" function to the local data, and writes the output to a temporary storage. A master node ensures that only one copy of redundant input data is processed
- Shuffle step
- Worker nodes redistribute data based on the output keys (produced by the "map()" function), such that all data belonging to one key is located on the same worker node
- Reduce step
- Worker nodes now process each group of output data, per key, in parallel
- MapReduce allows for distributed processing of the map and reduction operations
- Provided that each mapping operation is independent of the others, all maps can be performed in parallel though in practice this is limited by the number of independent data sources and/or the number of CPUs near each source
- A set of 'reducers' can perform the reduction phase, provided that all outputs of the map operation that share the same key are presented to the same reducer at the same time, or that the reduction function is associative
- The process can often appear inefficient compared to algorithms that are more sequential
--> because multiple rather than one instance of the reduction process must be run
- MapReduce can be applied to significantly larger datasets than "commodity" servers can handle a large server farm can use MapReduce to sort a petabyte of data in only a few hours
- The parallelism also offers some possibility of recovering from partial failure of servers or storage during the operation: if one mapper or reducer fails, the work can be rescheduled assuming the input data is still available
- Another way to look at MapReduce is as a 5-step parallel and distributed computation
- Prepare the Map() input
--> the "MapReduce system" designates Map processors, assigns the input key value K1 that each processor would work on, and provides that processor with all the input data associated with that key value.
- Run the user-provided Map() code
--> Map() is run exactly once for each K1 key value, generating output organized by key values K2.
- Shuffle the Map output to the Reduce processors
--> the MapReduce system designates Reduce processors, assigns the K2 key value each processor should work on, and provides that processor with all the Map-generated data associated with that key value.
- Run the user-provided Reduce() code
--> Reduce() is run exactly once for each K2 key value produced by the Map step.
- Produce the final output
--> the MapReduce system collects all the Reduce output, and sorts it by K2 to produce the final outcome
> These five steps can be logically thought of as running in sequence each step starts only after the previous step is completed – although in practice they can be interleaved as long as the final result is not affected
> In many situations, the input data might already be distributed among many different servers, in which case step 1 could sometimes be greatly simplified by assigning Map servers that would process the locally present input data
- The Map and Reduce functions of MapReduce are both defined with respect to data structured in (key, value) pairs. Map takes one pair of data with a type in one data domain, and returns a list of pairs in a different domain
= Map( k1, v1 ) --> list( k2, v2 )
- The Map function is applied in parallel to every pair (keyed by k1) in the input dataset. This produces a list of pairs (keyed by k2) for each call. After that, the MapReduce framework collects all pairs with the same key (k2) from all lists and groups them together, creating one group for each key
- The Reduce function is then applied in parallel to each group, which in turn produces a collection of values in the same domain
= Reduce( k2, list( v2 ) ) --> list( v3 )
- Each Reduce call typically produces either one value v3 or an empty return, though one call is allowed to return more than one value. The returns of all calls are collected as the desired result list
- Thus the MapReduce framework transforms a list of (key, value) pairs into a list of values. This behavior is different from the typical functional programming map and reduce combination, which accepts a list of arbitrary values and returns one single value that combines all the values returned by map
--> It is necessary but not sufficient to have implementations of the map and reduce abstractions in order to implement MapReduce. Distributed implementations of MapReduce require a means of connecting the processes performing the Map and Reduce phases
- This may be a distributed file system. Other options are possible, such as direct streaming from mappers to reducers, or for the mapping processors to serve up their results to reducers that query them.
- Dataflow
--> The frozen part of the MapReduce framework is a large distributed sort. The hot spots, which the application defines, are
- an Input reader
- The input reader divides the input into appropriate size 'splits' (in practice typically 64 MB to 128 MB) and the framework assigns one split to each Map function
- The input reader reads data from stable storage (typically a distributed file system) and generates key/value pairs
- A common example will read a directory full of text files and return each line as a record
- a Map function
- The Map function takes a series of key/value pairs, processes each, and generates zero or more output key/value pairs
- The input and output types of the map can be (and often are) different from each other
- If the application is doing a word count, the map function would break the line into words and output a key/value pair for each word
- Each output pair would contain the word as the key and the number of instances of that word in the line as the value
- a Partition function
- Each Map function output is allocated to a particular reducer by the application's partition function for sharding purposes
- The partition function is given the key and the number of reducers and returns the index of the desired reducer
- A typical default is to hash the key and use the hash value modulo the number of reducers
- It is important to pick a partition function that gives an approximately uniform distribution of data per shard for load-balancing purposes, otherwise the MapReduce operation can be held up waiting for slow reducers (reducers assigned more than their share of data) to finish
- a Compare function
- The input for each Reduce is pulled from the machine where the Map ran and sorted using the application's comparison function
- a Reduce function
- The framework calls the application's Reduce function once for each unique key in the sorted order
- The Reduce can iterate through the values that are associated with that key and produce zero or more outputs
- an Output writer
- The Output Writer writes the output of the Reduce to the stable storage
- Restricted programming framework
- MapReduce tasks must be written as acyclic dataflow programs, i.e. a stateless mapper followed by a stateless reducer, that are executed by a batch job scheduler
- This paradigm makes repeated querying of datasets difficult and imposes limitations that are felt in fields such as machine learning, where iterative algorithms that revisit a single working set multiple times are the norm
--> MapReduce is useful in a wide range of applications, including distributed pattern-based searching, distributed sorting, web link-graph reversal, Singular Value Decomposition, web access log stats, inverted index construction, document clustering, machine learning, and statistical machine translation. Moreover, the MapReduce model has been adapted to several computing environments like multi-core and many-core systems, desktop grids, volunteer computing environments, dynamic cloud environments, and mobile environments
- Hive
--> a data warehouse infrastructure built on top of Hadoop for providing data summarization, query, and analysis
--> developed by Facebook, Apache Hive is now used and developed by other companies such as Netflix and the Financial Industry Regulatory Authority
--> Amazon maintains a software fork of Apache Hive that is included in Amazon Elastic MapReduce on Amazon Web Services
- Features
--> Apache Hive supports analysis of large datasets stored in Hadoop's HDFS and compatible file systems such as Amazon S3 filesystem. It provides an SQL-like language called HiveQL with schema on read and transparently converts queries to MapReduce, Apache Tez and Spark jobs. All three execution engines can run in Hadoop YARN
--> To accelerate queries, it provides indexes, including bitmap indexes
- Indexing to provide acceleration, index type including compaction and Bitmap index as of 0.10, more index types are planned.
- Different storage types such as plain text, RCFile, HBase, ORC, and others.
- Metadata storage in an RDBMS, significantly reducing the time to perform semantic checks during query execution.
- Operating on compressed data stored into the Hadoop ecosystem using algorithms including DEFLATE, BWT, snappy, etc.
- Built-in user defined functions (UDFs) to manipulate dates, strings, and other data-mining tools. Hive supports extending the UDF set to handle use-cases not supported by built-in functions.
- SQL-like queries (HiveQL), which are implicitly converted into MapReduce or Tez, or Spark jobs.
- By default, Hive stores metadata in an embedded Apache Derby database, and other client/server databases like MySQL can optionally be used
- Hive QL
--> is based on SQL, HiveQL does not strictly follow the full SQL standard. HiveQL offers extensions not in SQL, including multitable inserts and create table as select, but only offers basic support for indexes
-->  lacks support for transactions and materialized views, and only limited subquery support
--> Support for insert, update, and delete with full ACID functionality
- Hive unit testing frameworks
- HiveQLUnit
- HiveRunner
- HiveTest
- Hive --> A petabyte scale data warehouse using hadoop
--> is developed by Facebook, designed to enable easy data summarization, ad-hoc querying and analysis of large volumes of data. It provides a simple query language called Hive QL, which is based on SQL
--> is not designed for online transaction processing and does not offer real-time queries and row level updates
--> is best used for batch jobs over large sets of immutable data
- Hive Metastore
- Store Hive metadata
- Configuration
- Embedded
- in-process metastore, in-process database
- Local
- in-process metastore, out-of-process database
- Remote
- out-of-process metastore,out-of-process database
- Hive Schema On Read
- Faster loads into the database (simply copy or move)
- Slower queries
- Flexibility multiple schemas for the same data
- Hive Tables
- Managed --> create table
- LOAD : File moved into Hive's data warehouse directory
- DROP : Both data and metadata are deleted.
- External --> create external table
- LOAD : No file moved
- DROP : Only metadata deleted
- Use when sharing data between Hive and Hadoop applications
or you want to use multiple schema on the same data
- Running Hive
- Hive shell
- Interactive --> hive
- Script --> hive -f myscript
- Inline --> hive -e 'SELECT * FROM mytable'
- System Architecture and Components
- Metastore
--> To store the meta data
- Query compiler and execution engine
--> To convert SQL queries to a sequence of map or reduce jobs that are then executed on Hadoop
- SerDe and ObjectInspectors
--> Programmable interfaces and implementations of common data formats and types
- UDF and UDAF
--> Programmable interfaces and implementations for user defined functions scalar and aggregate functions
- Client
--> Command line client similar to Mysql command line
- Link
MapReduce & Hive : http://kundjanasith.com/BigDataSchool/14-06-2016/BigData-Handon-March2015.pdf
Sqoop & Flume
13:00 - 17:30
- Sqoop
--> Sqoop [ SQL-to-Hadoop ] is a command-line interfaceapplication for transferring data between relational databases and Hadoop
--> supports incremental loads of a single table or a free form SQL query as well as saved jobs which can be run multiple times to import updates made to a database since the last import
- Imports
- can also be used to populate tables in Hive or HBase
- Exports
- can be used to put data from Hadoop into a relational database
--> Sqoop got the name from sql+hadoop. Sqoop became a top-level Apache project in March 2012
--> Pentaho provides open source Sqoop based connector steps, Sqoop Import and Sqoop Export, in their ETL suite Pentaho Data Integration
-->  Microsoft uses a Sqoop-based connector to help transfer data from Microsoft SQL Server databases to Hadoop
--> Couchbase, Inc. also provides a Couchbase Server-Hadoop connector by means of Sqoop
- Ralph Kimball --> The future of ETL
- Several big changes must take place in the ETL environment. First, the data feeds from original sources must support huge bandwidths, at least gigabytes per second
--> is straightforward command-line tool with the following capabilities
- Imports individual tables or entire databases to files in HDFS
- Generates Java classes to allow you to interact with your imported data-- - Provides the ability to import from SQL databases straight into your Hive data warehouse
- sqoop import
- sqoop import ( generic-args ) ( import-args )
- sqoop-import ( generic-args ) ( import-args )
- sqoop-import --connect jdbc:mysql:database_name
--username user_name
--table table_name
- --target-dir ( new or exist directory in HDFS )
- --where ( condition )
- --incremental ( mode )
- --check-column ( column name )
- --last value ( last check column values )
- sqoop export
- sqoop export ( generic-args ) ( import-args )
- sqoop-export ( generic-args ) ( import-args )
- sqoop export
--connect jdbd:mysql:database_name
--username user_name
--table table_name
--export-dir
- Flume
--> A distributed data transport and aggregation system for event  or log structured data
--> Principally designed for continuous data ingestion into Hadoop But more flexible than that
--> Architecture
- Click streams
Data origins ( Flume agents ) --> Flume collector node
- Aggregate data
Flume collector node --> HDFS
--> Terminology
- Every machine in Flume is a node
- Each node has a source and a sink
- Some sinks send data to collector nodes, which aggregate data from many agents before writing to HDFS
- All Flume nodes heartbeat to/receive config from master
- Events enter Flume within seconds of generation
--> is not an analytic system
- No ability to inspect message bodies
- No notion of aggregates,rolling counters, etc
- Hands-on --> Loading twitter  data to Hadoop HDFS
- Custom Flume Source
- Twitter --> Flume
- Sink to HDFS
- Flume --> HDFS
- JSON SerDe parse Data
- HDFS --> Hive
- Step
1. Installing Flume
2. Installing a jar file
3. Create a new Twitter App
4. Configuration the Flume App
5. Fetching the data from Twitter
6. View the streaming data
7. Analyse data using Hive
--> a distributed, reliable, and available service for efficiently collecting, aggregating, and moving large amounts of log data
--> has a simple and flexible architecture based on streaming data flows
--> robust and fault tolerant with tunable reliability mechanisms and many fai lover and recovery mechanisms
--> uses a simple extensible data model that allows for online analytic application
- Flum Event
- An event is the basic unit of the data transported inside Flume. It contains a payload of byte array that is to be transported from the source to the destination accompanied by optional headers
- Flume Agent
- An agent is an independent daemon process (JVM) in Flume. It receives the data (events) from clients or other agents and forwards it to its next destination (sink or agent)
- Flume may have more than one agent
- Source
- is the component of an Agent which receives data from the data generators and transfers it to one or more channels in the form of Flume events
- Channel
- is a transient store which receives the events from the source and buffers them till they are consumed by sinks. It acts as a bridge between the sources and the sinks
- Sink
- stores the data into centralized stores like HBase and HDFS. It consumes the data (events) from the channels and delivers it to the destination.
- The destination of the sink might be another agent or the central stores
- Interceptor
- is used to alter/inspect flume events which are transferred between source and channel
- Channel Selector
- is used to determine which channel is to be opted to transfer the data in case of multiple channels
- There are two types of channel selectors
- Default channel selectors
- These are also known as replicating channel selectors they replicates all the events in each channel.
- Multiplexing channel selectors
- These decides the channel to send an event based on the address in the header of that event
- Sink Processor
- These are used to invoke a particular sink from the selected group of sinks. These are used to create fail over paths for your sinks or load balance events across multiple sinks from a channel
- Data Flow
--> Flume is a framework which is used to move log data into HDFS. Generally events and log data are generated by the log servers and these servers have Flume agents running on them. These agents receive the data from the data generators
- Multi-hop Flow
- Within Flume, there can be multiple agents and before reaching the final destination, an event may travel through more than one agent
- Fan-out Flow
- The data flow from one source to multiple channels
- Replicating
- The data flow where the data will be replicated in all the configured channels.
- Multiplexing
- The data flow where the data will be sent to a selected channel which is mentioned in the header of the event.
- Fan-in Flow
- The data flow in which the data will be transferred from many sources to one channel
- Failure Handling
- In Flume, for each event, two transactions take place: one at the sender and one at the receiver
- The sender sends events to the receiver. Soon after receiving the data, the receiver commits its own transaction and sends a “received” signal to the sender
- After receiving the signal, the sender commits its transaction.
- Sender will not commit its transaction till it receives a signal from the receiver.
- Configuration
- Name the components of the current agent.
- agent_name.sources
- agent_name.sinks
- agent_name.channels
- Describe/Configure the source.
- source_name.type
- source_name.property2
- source_name.property3
- Describe/Configure the sink.
- sink_name.type
- sink_name.property2
- sink_name.property3
- Describe/Configure the channel.
- channel_name.type
- channel_name.property2
- channel_name.property3
- Bind the source and the sink to the channel.
- source_name.channels
- sink_name.channels
- Flume Agent
- agent #Command to start the Flume agent
- --conf ,-c<conf> #Use configuration file in the conf directory
- -f<file> #Specifies a config file path, if missing
- --name, -n <name> #Name of the twitter agent
- -D property =value #Sets a Java system property value.
- Sequence Generator Source
--> is the source that generates the events continuously. It maintains a counter that starts from 0 and increments by 1
--> is used for testing purpose
- Channels
- Source type
- Channels
--> To configure the memory channel, you mustprovide a value to the type of the channel
- type
- It holds the type of the channel. In our example the type is MemChannel.
- Capacity
- It is the maximum number of events stored in the channel. Its default value is 100.
- TransactionCapacity
- It is the maximum number of events the channel accepts or sends. Its default is 100.
- HDFS Sink
- Channel
- type --> hdfs
- hdfs.path --> the path of the directory in HDFS where data is to be stored.
- fileType --> This is the required file format of our HDFS file. SequenceFile, DataStream and CompressedStream are the three types available with this stream. In our example, we are using the DataStream.
- writeFormat --> Could be either text or writable.
- batchSize --> It is the number of events written to a file before it is flushed into the HDFS. Its default value is 100.
- rollsize --> It is the file size to trigger a roll. It default value is 100.
- rollCount --> It is the number of events written into the file before it is rolled. Its default value is 10.
- Link
Sqoop & Flume : http://kundjanasith.com/BigDataSchool/14-06-2016/Flume-May2015.pdf
